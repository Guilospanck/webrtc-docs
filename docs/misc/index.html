<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Misc</title><link rel="icon" type="image/svg+xml" href="/webrtc-docs/favicon.svg"><link rel="icon" href="/webrtc-docs/favicon.ico"><style>:root{--bg: #141414;--surface: #1b1b1b;--surface-2: #202020;--ink: #e8e6e3;--muted: #a3a3a3;--accent: #7aa2f7;--accent-2: #87c6a5;--border: #2b2b2b;--code-bg: #0f1115;--code-ink: #e8e6e3;font-family:"Source Sans 3",IBM Plex Sans,Work Sans,sans-serif}*{box-sizing:border-box}body{margin:0;background:radial-gradient(circle at top left,#1f1f1f,#141414 55%,#111);color:var(--ink)}.layout{display:grid;grid-template-columns:minmax(240px,300px) 1fr;min-height:100vh}.sidebar{background:var(--surface);border-right:1px solid var(--border);padding:2rem 1.5rem;position:sticky;top:0;height:100vh;overflow-y:auto}.brand{font-size:.9rem;letter-spacing:.22em;text-transform:uppercase;margin-bottom:1.75rem;color:var(--muted)}.sidebar ul{list-style:none;padding:0;margin:0}.sidebar li{margin:.35rem 0}.sidebar a{color:var(--ink);text-decoration:none;font-weight:500;font-size:.95rem}.sidebar a:hover{color:var(--accent)}.sidebar ul ul{margin-top:.35rem;margin-left:.65rem;padding-left:.65rem;border-left:1px solid var(--border)}.content{padding:3.5rem 5vw;max-width:820px}h1{font-size:2.15rem;margin-bottom:1.25rem;font-weight:600}h2,h3,h4{font-weight:600;margin-top:2rem}.markdown{line-height:1.75;font-size:1.02rem;color:var(--ink)}.markdown a{color:var(--accent);text-decoration:none;border-bottom:1px solid transparent}.markdown a:hover{border-bottom-color:var(--accent)}.markdown pre{background:var(--code-bg);color:var(--code-ink);padding:1rem;overflow-x:auto;border-radius:8px}.markdown code{background:#ffffff0f;padding:.15rem .35rem;border-radius:4px}.markdown blockquote{margin:1.5rem 0;padding:.6rem 1rem;border-left:3px solid var(--border);background:var(--surface-2);color:var(--muted)}@media(max-width:900px){.layout{grid-template-columns:1fr}.sidebar{position:static;height:auto;border-right:none;border-bottom:1px solid var(--border)}}
</style></head> <body> <div class="layout"> <aside class="sidebar"> <div class="brand">WebRTC</div> <nav> <ul> <li> <a href="/webrtc-docs/docs/general/">General</a>  </li><li> <a href="/webrtc-docs/docs/webrtc-dev/">WebRTC - Dev</a> <ul> <li> <a href="/webrtc-docs/docs/coturn-turn-server/">Coturn - TURN server</a>  </li> </ul> </li><li> <a href="/webrtc-docs/docs/metrics/">Metrics</a>  </li><li> <a href="/webrtc-docs/docs/debugging/">Debugging</a>  </li><li> <a href="/webrtc-docs/docs/planning/">Planning</a>  </li><li> <a href="/webrtc-docs/docs/misc/">Misc</a> <ul> <li> <a href="/webrtc-docs/docs/adaptive-strategies/">Adaptive Strategies</a>  </li><li> <a href="/webrtc-docs/docs/topologies/">Topologies</a>  </li><li> <a href="/webrtc-docs/docs/servers/">Servers</a>  </li><li> <a href="/webrtc-docs/docs/mental-model-triangle/">Mental-Model Triangle</a> <ul> <li> <a href="/webrtc-docs/docs/rtcrtpsender/">RTCRtpSender</a>  </li><li> <a href="/webrtc-docs/docs/rtcrtpreceiver/">RTCRtpReceiver</a>  </li><li> <a href="/webrtc-docs/docs/why-is-mid-stable/">Why is MID stable?</a>  </li> </ul> </li><li> <a href="/webrtc-docs/docs/transmission-protocols/">Transmission Protocols</a>  </li><li> <a href="/webrtc-docs/docs/renegotiations/">Renegotiations</a>  </li><li> <a href="/webrtc-docs/docs/data-channels/">Data Channels</a>  </li> </ul> </li> </ul> </nav> </aside> <main class="content">  <article> <h1>Misc</h1> <div class="markdown"> <h2 id="adaptive-strategies">Adaptive Strategies</h2>
<h2 id="adaptive-quality-strategies">Adaptive Quality Strategies</h2>








































<table><thead><tr><th>Aspect</th><th>Simulcast</th><th>SVC</th></tr></thead><tbody><tr><td>Encodes</td><td>Multiple independent streams</td><td>One layered stream</td></tr><tr><td>Bandwidth</td><td>Higher</td><td>Lower</td></tr><tr><td>CPU cost</td><td>Higher</td><td>Lower</td></tr><tr><td>Complexity</td><td>Lower</td><td>Higher</td></tr><tr><td>Flexibility</td><td>Switch between streams</td><td>Add/remove layers</td></tr><tr><td>Typical WebRTC SFU</td><td>‚úÖ Very common</td><td>‚ö†Ô∏è Less common</td></tr></tbody></table>
<h3 id="simulcast-multiple-roads">Simulcast (multiple roads)</h3>
<p>It‚Äôs an encoding strategy where a sender encodes the same media into multiple streams with different qualities (resolutions, bitrates).</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="bash"><code><span class="line"><span style="color:#B392F0">----------</span><span style="color:#9ECBFF"> 1080p</span><span style="color:#9ECBFF"> @</span><span style="color:#9ECBFF"> 4Mbps</span><span style="color:#E1E4E8">       </span></span>
<span class="line"><span style="color:#B392F0">       ----------</span><span style="color:#9ECBFF"> 720p</span><span style="color:#9ECBFF"> @</span><span style="color:#9ECBFF"> 2Mbps</span><span style="color:#E1E4E8">        </span></span>
<span class="line"><span style="color:#B392F0">Sender</span><span style="color:#79B8FF"> ----------</span><span style="color:#9ECBFF"> 360p</span><span style="color:#9ECBFF"> @</span><span style="color:#9ECBFF"> 500Kbps</span><span style="color:#9ECBFF">           Receiver</span></span>
<span class="line"><span style="color:#B392F0">       ----------</span><span style="color:#9ECBFF"> ...</span></span>
<span class="line"><span style="color:#B392F0">       ----------</span><span style="color:#9ECBFF"> ...</span></span></code></pre>
<p>Pros:</p>
<ul>
<li>Simple conceptually</li>
<li>Works with existing codecs</li>
<li>Easy for SFU to route</li>
</ul>
<p>Cons:</p>
<ul>
<li>Higher CPU usage (multiple encodes on the sender side)</li>
<li>Higher bandwidth from sender</li>
<li>No sharing of data between qualities</li>
</ul>
<h3 id="svc-scalable-video-coding-one-road-with-multiple-lanes">SVC (Scalable Video Coding): one road with multiple lanes</h3>
<p>Encoding strategy where a single encoded stream contains multiple layers.</p>
<p>You have one base layer (low quality) and then add enhancement layers on top of it. The receivers can subscribe to some layers.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="bash"><code><span class="line"><span style="color:#B392F0">Sender</span><span style="color:#79B8FF">   -----------------------</span><span style="color:#9ECBFF">  Receiver</span></span>
<span class="line"><span style="color:#E1E4E8">         (</span><span style="color:#B392F0">Multi-layered</span><span style="color:#9ECBFF"> stream</span><span style="color:#E1E4E8">)</span></span></code></pre>
<p>Pros:</p>
<ul>
<li>More bandwidth-efficient</li>
<li>Less redundant data</li>
<li>Single encoder instance</li>
</ul>
<p>Cons:</p>
<ul>
<li>More complex codec and tooling</li>
<li>Harder to deploy and debug</li>
<li>Not all codecs/browsers support it equally</li>
</ul>
<h2 id="topologies">Topologies</h2>



































<table><thead><tr><th>Property</th><th>Mesh</th><th>SFU</th><th>MCU</th></tr></thead><tbody><tr><td>Server CPU</td><td>none</td><td>low</td><td>high</td></tr><tr><td>Client upload</td><td>n‚àí1</td><td>1</td><td>1</td></tr><tr><td>Client download</td><td>n‚àí1</td><td>n‚àí1</td><td>1</td></tr><tr><td>Media mixing</td><td>no</td><td>no</td><td>yes</td></tr></tbody></table>
<h2 id="p2p-mesh">P2P (Mesh)</h2>
<p>Each peer talks to another peer.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="bash"><code><span class="line"><span style="color:#B392F0">A</span><span style="color:#9ECBFF"> ‚Üî</span><span style="color:#9ECBFF"> B</span></span>
<span class="line"><span style="color:#B392F0">‚Üï</span><span style="color:#9ECBFF">   ‚Üï</span></span>
<span class="line"><span style="color:#B392F0">C</span><span style="color:#9ECBFF"> ‚Üî</span><span style="color:#9ECBFF"> D</span></span></code></pre>
<ul>
<li>Not suitable for when a call starts to have more than 1-1, due to high upload bandwidth (needs to encode and send the stream to each one of the participants) and high CPU load on the sender side</li>
<li>Best for 1:1 calls</li>
</ul>
<h2 id="sfu-selective-forwarding-unit--used-a-lot">SFU (Selective Forwarding Unit) ‚Üê Used a lot</h2>
<p>You have a SFU server that forwards the sender stream to each one of the connected participants. It‚Äôs a HUB that acts intelligently, forwarding different qualities to different clients depending on their capabilities/network, without encoding/decoding media.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="bash"><code><span class="line"><span style="color:#B392F0">A</span></span>
<span class="line"><span style="color:#F97583">           |</span><span style="color:#B392F0">                              A</span><span style="color:#9ECBFF"> sends</span><span style="color:#9ECBFF"> a</span><span style="color:#9ECBFF"> stream</span><span style="color:#9ECBFF"> to</span><span style="color:#9ECBFF"> SFU</span></span>
<span class="line"><span style="color:#F97583">           |</span><span style="color:#B392F0">                              B</span><span style="color:#9ECBFF"> sends</span><span style="color:#9ECBFF"> a</span><span style="color:#9ECBFF"> stream</span><span style="color:#9ECBFF"> to</span><span style="color:#9ECBFF"> SFU</span></span>
<span class="line"><span style="color:#F97583">           |</span><span style="color:#B392F0">                              C</span><span style="color:#9ECBFF"> sends</span><span style="color:#9ECBFF"> a</span><span style="color:#9ECBFF"> stream</span><span style="color:#9ECBFF"> to</span><span style="color:#9ECBFF"> SFU</span></span>
<span class="line"><span style="color:#B392F0">  B</span><span style="color:#79B8FF"> ------</span><span style="color:#9ECBFF"> SFU</span><span style="color:#79B8FF"> ------</span><span style="color:#9ECBFF"> C</span><span style="color:#9ECBFF">                   D</span><span style="color:#9ECBFF"> receives</span><span style="color:#79B8FF"> 3</span><span style="color:#9ECBFF"> streams</span></span>
<span class="line"><span style="color:#F97583">           |</span></span>
<span class="line"><span style="color:#F97583">           |</span></span>
<span class="line"><span style="color:#F97583">           |</span></span>
<span class="line"><span style="color:#B392F0">           D</span></span></code></pre>
<ul>
<li>Sender sends a stream only to the SFU server</li>
<li>Receivers will receive streams from each one of the senders</li>
<li>Clients will decode multiple streams</li>
<li>Good for group calls</li>
<li>Low latency</li>
</ul>
<blockquote>
<p>üí° One thing that got in my mind was the difference between SFU and TURN: they solve different problems.</p>
<ul>
<li>
<p>In a normal 1-1 call, if you DON‚ÄôT use SFU, you will connect a peer A to a peer B via either host / public (srflx, prflx) / or TURN</p>
</li>
<li>
<p>If you DO use a SFU server, then you will do the same connection, but this time peer A to SFU and peer B to SFU. Peers don‚Äôt connect to each other, they connect only to the SFU and this connection will also be via host / or public (srflx, prflx) / or TURN server.</p>
</li>
</ul>
<p>So yes: you do need <em>another server if you‚Äôre going to use SFU.</em></p>
</blockquote>
<h2 id="mcu-multipoint-control-unit--not-very-used-legacy">MCU (Multipoint Control Unit) ‚Üê Not very used (legacy)</h2>
<p>You have a MCU server that mix all the received streams into just one and send them to the connected participants.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="bash"><code><span class="line"><span style="color:#B392F0">A</span><span style="color:#9ECBFF"> sends</span><span style="color:#9ECBFF"> a</span><span style="color:#9ECBFF"> stream</span><span style="color:#9ECBFF"> to</span><span style="color:#9ECBFF"> MCU</span></span>
<span class="line"><span style="color:#B392F0">                                B</span><span style="color:#9ECBFF"> sends</span><span style="color:#9ECBFF"> a</span><span style="color:#9ECBFF"> stream</span><span style="color:#9ECBFF"> to</span><span style="color:#9ECBFF"> MCU</span></span>
<span class="line"><span style="color:#B392F0">                                C</span><span style="color:#9ECBFF"> sends</span><span style="color:#9ECBFF"> a</span><span style="color:#9ECBFF"> stream</span><span style="color:#9ECBFF"> to</span><span style="color:#9ECBFF"> MCU</span></span>
<span class="line"><span style="color:#B392F0">                                ABCD</span><span style="color:#9ECBFF"> receives</span><span style="color:#9ECBFF"> one</span><span style="color:#9ECBFF"> mixed</span><span style="color:#9ECBFF"> stream</span></span>
<span class="line"><span style="color:#E1E4E8">                                </span></span>
<span class="line"><span style="color:#B392F0">A</span><span style="color:#9ECBFF"> ‚Üí</span><span style="color:#9ECBFF">     ‚îê</span></span>
<span class="line"><span style="color:#B392F0">B</span><span style="color:#9ECBFF"> ‚Üí</span><span style="color:#9ECBFF"> MCU</span><span style="color:#9ECBFF"> ‚îú‚Üí</span><span style="color:#9ECBFF"> mixed</span><span style="color:#9ECBFF"> stream</span><span style="color:#9ECBFF"> ‚Üí</span><span style="color:#9ECBFF"> A</span></span>
<span class="line"><span style="color:#B392F0">C</span><span style="color:#9ECBFF"> ‚Üí</span><span style="color:#9ECBFF">     ‚îò</span><span style="color:#9ECBFF">               ‚Üí</span><span style="color:#9ECBFF"> B</span></span>
<span class="line"><span style="color:#B392F0">                        ‚Üí</span><span style="color:#9ECBFF"> C</span></span></code></pre>
<ul>
<li>Senders send their stream to MCU</li>
<li>MCU mix/composites and sends a single stream to each connected peer</li>
<li>High CPU usage on the MCU server</li>
<li>More latency and cost (the server must handle a lot of encoding/mixing/composing)</li>
</ul>
<h2 id="servers">Servers</h2>
<p>In WebRTC we (might) have these servers.</p>
<h2 id="signaling-server">Signaling server</h2>
<p>Responsible for exchanging peers capabilities (SDP - Session Description Protocol) and ICE (Internet Connection Establishment) candidates. It‚Äôs only needed when a (re)negotiation is needed.</p>
<h2 id="stunturn-server">STUN/TURN server</h2>
<p>These are used to gather ICE candidates. Usually the STUN server is gonna be a Google one (<code>stun:stun.l.google.com:19302</code>) and the TURN server will be either a self-hosted (like <a href="/webrtc-docs/docs/coturn-turn-server/">Coturn - TURN server</a> ) or a 3rd party like <a href="https://developers.cloudflare.com/realtime/turn/">Cloudflare TURN service</a> or <a href="https://www.twilio.com/docs/stun-turn">Twilio Network Traversal Service</a>.</p>
<h2 id="sfu-selective-forwarding-unit-server">SFU (Selective Forwarding Unit) server</h2>
<p>This will be necessary if you want to have group calls, as the P2P (mesh) topology doesn‚Äôt work well when more participants start to gather around (bandwidth starts to explode, clients have to handle many encodes/decodes).</p>
<h2 id="mental-model-triangle">Mental-Model Triangle</h2>
<p>Transceivers vs Tracks vs Streams.</p>
<h2 id="transceivers">Transceivers</h2>
<blockquote>
<p>üí° A transceiver is about capability and negotiation, not content.</p>
</blockquote>
<h3 id="what-it-is">What it is</h3>
<p>A media slot + transport definition</p>
<h3 id="what-it-answers">What it answers</h3>
<p>‚ÄúIs there a lane for audio/video here, and in which direction?‚Äù</p>
<h3 id="key-properties">Key properties</h3>
<ul>
<li>Lives on <code>RTCPeerConnection</code></li>
<li>Has a direction (<code>sendrecv</code>, <code>recvonly</code>, etc)</li>
<li>Owns:
<ul>
<li>an <code>RTCRtpSender</code>:</li>
</ul>
</li>
</ul>
<h2 id="rtcrtpsender">RTCRtpSender</h2>
<p>Part of a transceiver responsible for sending media out.</p>
<ul>
<li>Takes a local <code>MediaStreamTrack</code></li>
<li>Encodes it</li>
<li>Packetize it as RTP</li>
<li>Send to the remote peer</li>
</ul>
<blockquote>
<p>üí° When you replace a track without changing the transceiver, you don‚Äôt need renegotiation.</p>
</blockquote>
<h3 id="comparison">Comparison</h3>





























<table><thead><tr><th>Sender</th><th>Receiver</th></tr></thead><tbody><tr><td>Local ‚Üí Remote</td><td>Remote ‚Üí Local</td></tr><tr><td>Owns local track</td><td>Owns remote track</td></tr><tr><td>Track is optional</td><td>Track exists when media arrives</td></tr><tr><td>You control it</td><td>Browser controls it</td></tr><tr><td>Can replace track</td><td>Cannot replace track</td></tr></tbody></table>
<h3 id="example-audio-call">Example audio call</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="typescript"><code><span class="line"><span style="color:#E1E4E8">You                                                        Remote peer</span></span>
<span class="line"><span style="color:#F97583">----</span><span style="color:#F97583">                                                       -----------</span></span>
<span class="line"><span style="color:#E1E4E8">Mic track ‚îÄ‚ñ∂ RTCRtpSender ‚îÄ‚îÄ‚îÄ‚ñ∂ </span><span style="color:#79B8FF">RTP</span><span style="color:#E1E4E8"> ‚îÄ‚îÄ‚îÄ‚ñ∂ RTCRtpReceiver ‚îÄ‚ñ∂ Remote track</span></span></code></pre>
<p>At the same time, the reverse happens on the same transceiver.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>- and `RTCRtpReceiver`:</span></span></code></pre>
<h2 id="rtcrtpreceiver">RTCRtpReceiver</h2>
<p>Part of a transceiver that receives media in.</p>
<ul>
<li>Receives RTP packets from the network</li>
<li>Decodes them</li>
<li>Exposes them as <code>MediaStreamTrack</code></li>
</ul>
<h3 id="comparison-1">Comparison</h3>





























<table><thead><tr><th>Sender</th><th>Receiver</th></tr></thead><tbody><tr><td>Local ‚Üí Remote</td><td>Remote ‚Üí Local</td></tr><tr><td>Owns local track</td><td>Owns remote track</td></tr><tr><td>Track is optional</td><td>Track exists when media arrives</td></tr><tr><td>You control it</td><td>Browser controls it</td></tr><tr><td>Can replace track</td><td>Cannot replace track</td></tr></tbody></table>
<h3 id="example-audio-call-1">Example audio call</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="typescript"><code><span class="line"><span style="color:#E1E4E8">You                                                        Remote peer</span></span>
<span class="line"><span style="color:#F97583">----</span><span style="color:#F97583">                                                       -----------</span></span>
<span class="line"><span style="color:#E1E4E8">Mic track ‚îÄ‚ñ∂ RTCRtpSender ‚îÄ‚îÄ‚îÄ‚ñ∂ </span><span style="color:#79B8FF">RTP</span><span style="color:#E1E4E8"> ‚îÄ‚îÄ‚îÄ‚ñ∂ RTCRtpReceiver ‚îÄ‚ñ∂ Remote track</span></span></code></pre>
<p>At the same time, the reverse happens on the same transceiver.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>- Gets a `MID` after negotiation:</span></span></code></pre>
<h2 id="why-is-mid-stable">Why is MID stable?</h2>
<ul>
<li>Transceiver stays</li>
<li>Sender stays</li>
<li>Receiver stays</li>
<li>Track may change</li>
</ul>
<p>This is why MIDs stay stable.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>- Exists even with no track attached</span></span></code></pre>
<h3 id="example">Example</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="typescript"><code><span class="line"><span style="color:#E1E4E8">pc.</span><span style="color:#B392F0">addTransceiver</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"audio"</span><span style="color:#E1E4E8">, { direction: </span><span style="color:#9ECBFF">"recvonly"</span><span style="color:#E1E4E8"> });</span></span></code></pre>
<p>You just said: ‚ÄúI want one incoming audio slot‚Äù.</p>
<h3 id="mental-model">Mental model</h3>
<blockquote>
<p>üí° It‚Äôs like a pipe that has some valve that allows you to choose the type of material that it holds and to which direction it flows.</p>
</blockquote>
<h3 id="important">Important</h3>
<blockquote>
<p>üí° Each transceiver can have AT MOST 1 track (it can have 0 or 1) in each direction.<br>
If the transceiver is <code>sendrecv</code> direction, then it can have 1 local track and 1 remote track.</p>
</blockquote>
<blockquote>
<p>üí° Every time you change a transceiver (add, delete, update), we need to have renegotiation because the SDP (Session Description Protocol) will also change. Changing just the track doesn‚Äôt trigger reconnection.</p>
<p>Even if the transceiver has the same configuration from another one, for the WebRTC it‚Äôs a different transceiver (gets a different MID) and therefore is added to the SDP, triggering renegotiation.</p>
<p>See <a href="/webrtc-docs/docs/renegotiations/">Renegotiations</a> for more.</p>
</blockquote>
<blockquote>
<p>üí° One SUPER IMPORTANT THING:</p>
<p>When, let‚Äôs say, a remote peer creates a video channel with the local peer, the browser automatically checks the SDP (when giving an answer) and says ‚Äúwell, here is a sendrecv video media transceiver that I don‚Äôt know about. I will just create a recvonly transceiver from my side because that‚Äôs the safest option‚Äù.</p>
<p>Meaning: if you want to have your transceiver also be sendrecv, you have to explicitly say that and then renegotiate.</p>
</blockquote>
<h2 id="tracks">Tracks</h2>
<h3 id="what-it-is-1">What it is</h3>
<p>A single source of media.</p>
<h3 id="what-it-answers-1">What it answers</h3>
<p>‚ÄúWhat exact audio or video am I sending or receiving?‚Äù</p>
<p>Examples: microphone audio, webcam video, screen share</p>
<h3 id="key-properties-1">Key properties</h3>
<ul>
<li>Type <code>audio</code> or <code>video</code></li>
<li>Has a <code>MediaStreamTrack.id</code></li>
<li>Can be:
<ul>
<li>enabled / disabled</li>
<li>stopped</li>
<li>replaced</li>
</ul>
</li>
</ul>
<h3 id="example-1">Example</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="typescript"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> track</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> stream.</span><span style="color:#B392F0">getAudioTracks</span><span style="color:#E1E4E8">()[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#E1E4E8">transceiver.sender.</span><span style="color:#B392F0">replaceTrack</span><span style="color:#E1E4E8">(track);</span></span></code></pre>
<h3 id="mental-model-1">Mental model</h3>
<blockquote>
<p>üí° The track is the type of material that is flowing in the pipe (transceiver).</p>
</blockquote>
<h2 id="streams-mediastream">Streams (MediaStream)</h2>
<blockquote>
<p>üí° Streams are mostly cosmetic in modern WebRTC.</p>
</blockquote>
<h3 id="what-it-is-2">What it is</h3>
<p>A logical group of tracks.</p>
<h3 id="what-it-answers-2">What it answers</h3>
<p>‚ÄúWhich tracks belong together?‚Äù</p>
<h3 id="mental-model-2">Mental model</h3>
<blockquote>
<p>üí° The streams are just labels that you give to the materials (tracks). You could say material 1 and material 2 is labeled ‚ÄúGuilherme‚Äôs house‚Äù.</p>
</blockquote>
<h2 id="transmission-protocols">Transmission Protocols</h2>
<p>Audio/video (media streams) use RTP. Data channels use SCTP.</p>
<h2 id="rtp---real-time-transport-protocol">RTP - Real-time Transport Protocol</h2>
<p>RTP (Real-time Transport Protocol) is a protocol that defines how the media (audio/video) is transmitted over the wire.</p>
<p>RTP packets are the smallest unit of some media.</p>
<p>RTP stream is just a flow of RTP packets that belong together (share the same SSRC - <strong>Synchronisation Source identifier, which is basically the stream id</strong>).</p>





























<table><thead><tr><th>Concept</th><th>Represents</th></tr></thead><tbody><tr><td>RTP packet</td><td>One small chunk of media</td></tr><tr><td>RTP stream (SSRC)</td><td>One continuous media flow</td></tr><tr><td>RTCRtpSender</td><td>Produces an RTP stream</td></tr><tr><td>RTCRtpReceiver</td><td>Consumes an RTP stream</td></tr><tr><td>Transceiver</td><td>Owns the RTP stream definition</td></tr></tbody></table>
<p>A <code>track</code> is conceptual. What really goes over the wire is an RTP stream.</p>
<h3 id="ssrc---synchronisation-source-identifier">SSRC - Synchronisation Source Identifier</h3>
<p>It‚Äôs basically the stream id. It tells the receiver which RTP packets belong to the same stream.</p>
<ul>
<li>It is NOT stable across renegotiations</li>
<li>NOT globally unique</li>
<li>Only meaningful within one PeerConnection</li>
</ul>
<h2 id="sctp---stream-control-transmission-protocol">SCTP - Stream Control Transmission Protocol</h2>
<p>Data channels use SCTP over DTLS over ICE instead of RTP.</p>
<p>One SCTP supports multiple logical streams inside one connection.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="typescript"><code><span class="line"><span style="color:#E1E4E8">One </span><span style="color:#79B8FF">SCTP</span><span style="color:#E1E4E8"> association</span></span>
<span class="line"><span style="color:#E1E4E8">‚îî‚îÄ‚îÄ Stream </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8"> ‚Üí DataChannel </span><span style="color:#9ECBFF">"chat"</span></span>
<span class="line"><span style="color:#E1E4E8">‚îî‚îÄ‚îÄ Stream </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8"> ‚Üí DataChannel </span><span style="color:#9ECBFF">"control"</span></span>
<span class="line"><span style="color:#E1E4E8">‚îî‚îÄ‚îÄ Stream </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8"> ‚Üí DataChannel </span><span style="color:#9ECBFF">"game-state"</span></span></code></pre>
<p>That‚Äôs the way we can have multiple data channels without triggering renegotiation after the first data channel creation, because they use the same data channel that was defined in SDP.</p>
<h2 id="renegotiations">Renegotiations</h2>
<blockquote>
<p>üí° Renegotiations happen every time the SDP (Session Description Protocol) changes.</p>
</blockquote>
<blockquote>
<p>üí° - Tracks are <strong>content</strong></p>
<ul>
<li>
<p>Transceivers are <strong>contracts</strong></p>
</li>
<li>
<p>SDP negotiates contracts, not content</p>
</li>
</ul>
</blockquote>
<h2 id="triggers">Triggers</h2>
<ul>
<li>Every time a transceiver is added/removed/updated</li>
<li>First time a data channel is created</li>
</ul>
<h2 id="do-not-trigger">Do NOT trigger</h2>
<ul>
<li>Swapping tracks</li>
<li>Data channels created after the first one</li>
</ul>
<h2 id="practical-advices">Practical advices</h2>
<h3 id="prefer-fewer-transceivers">‚úÖ¬†Prefer fewer transceivers</h3>
<p>Reuse them when you can.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="typescript"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> tx</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> pc.</span><span style="color:#B392F0">addTransceiver</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"video"</span><span style="color:#E1E4E8">, { direction: </span><span style="color:#9ECBFF">"sendrecv"</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#F97583">await</span><span style="color:#E1E4E8"> tx.sender.</span><span style="color:#B392F0">replaceTrack</span><span style="color:#E1E4E8">(newCameraTrack);</span></span></code></pre>
<h3 id="dont-create-transceivers-dynamically-when-not-needed">‚ùå¬†Don‚Äôt create transceivers dynamically when not needed</h3>
<p>Each one:</p>
<ul>
<li>Bloats SDP</li>
<li>Slows negotiation</li>
<li>Complicate signalling</li>
</ul>
<h3 id="pre-create-transceivers-when-possible">‚úÖ¬†Pre-create transceivers when possible</h3>
<h2 id="data-channels">Data Channels</h2>
<p>DataChannels are arbitrary application data that‚Äôs not audio/video. Examples: <code>chat messages</code>, <code>cursor positions</code>, <code>game state</code>, <code>whiteboard strokes</code>, <code>file transfer</code>, <code>control messages (mute, pause, sync)</code>. They often complement media (audio/video).</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="typescript"><code><span class="line"><span style="color:#E1E4E8">DataChannel</span></span>
<span class="line"><span style="color:#E1E4E8">   ‚Üì</span></span>
<span class="line"><span style="color:#B392F0">SCTP</span><span style="color:#E1E4E8"> (Stream Control Transmission Protocol)</span></span>
<span class="line"><span style="color:#E1E4E8">   ‚Üì</span></span>
<span class="line"><span style="color:#B392F0">DTLS</span><span style="color:#E1E4E8"> (Datagram Transport Layer Security)</span></span>
<span class="line"><span style="color:#E1E4E8">   ‚Üì</span></span>
<span class="line"><span style="color:#79B8FF">UDP</span></span></code></pre>
<p>See <a href="/webrtc-docs/docs/transmission-protocols/">Transmission Protocols</a> for more about SCTP.</p>
<h2 id="superpowers">‚ÄúSuperpowers‚Äù</h2>
<h3 id="configurable-reliability">Configurable reliability</h3>
<p>Allows you to choose: reliable, unreliable, partially reliable (time-based or retry-limited). Example:</p>
<ul>
<li>chat ‚Üí reliable</li>
<li>cursor position ‚Üí unreliable</li>
<li>game state ‚Üí retry for 50ms, then drop</li>
</ul>
<h3 id="ordered-or-unordered-delivery">Ordered or unordered delivery</h3>
<ul>
<li>ordered ‚Üí messages arrive in sequence</li>
<li>unordered ‚Üí faster, no waiting</li>
</ul>
<h3 id="no-hol-blocking">No HOL blocking</h3>
<p>One delayed message doesn‚Äôt block others.</p>
<h3 id="message-based-not-byte-streams">Message-based (not byte streams)</h3>
<p>You send:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="typescript"><code><span class="line"><span style="color:#E1E4E8">channel.</span><span style="color:#B392F0">send</span><span style="color:#E1E4E8">({ x: </span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">, y: </span><span style="color:#79B8FF">32</span><span style="color:#E1E4E8"> })</span></span></code></pre>
<p>You receive exactly one message. No framing. No delimiters.</p>
<h3 id="datachannels-vs-websockets">DataChannels vs WebSockets</h3>








































<table><thead><tr><th>Feature</th><th>DataChannel</th><th>WebSocket</th></tr></thead><tbody><tr><td>Topology</td><td>Peer-to-peer</td><td>Client‚Äìserver</td></tr><tr><td>Transport</td><td>UDP (SCTP)</td><td>TCP</td></tr><tr><td>Reliability</td><td>Configurable</td><td>Always reliable</td></tr><tr><td>Ordering</td><td>Optional</td><td>Always ordered</td></tr><tr><td>Latency</td><td>Very low</td><td>Higher under loss</td></tr><tr><td>NAT traversal</td><td>Built-in</td><td>Manual</td></tr></tbody></table>
<h2 id="message-size-limits"><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Using_data_channels#understanding_message_size_limits">Message size limits</a></h2>
<p>While most browsers allow sending messages of at least 256KB, there are downsides sending large messages, it can also lead to HOL blocking, which in turn affect negatively the latency of messages on other data channels.</p>
<p>The maximum message size can be negotiated via the <code>max-message-size</code> attribute in SDP (although it‚Äôs something that you can NOT change easily. It depends on the underlying connection and implementation).</p>
<p>The default limit for a message size is 64KB.</p> </div> </article>  </main> </div> </body></html>